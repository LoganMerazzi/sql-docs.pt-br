---
title: Função SQLSetStmtAttr | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 583639a5cd4680bf6cfcf03bbaf6ee9eb63adba8
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/15/2019
ms.locfileid: "68039651"
---
# <a name="sqlsetstmtattr-function"></a>Função SQLSetStmtAttr
**Conformidade com**  
 Versão introduzida: Conformidade com padrões 3.0 ODBC: ISO 92  
  
 **Resumo**  
 **SQLSetStmtAttr** define atributos relacionados a uma instrução.  
  
> [!NOTE]
>  Para obter mais informações sobre o que o Gerenciador de Driver mapeia essa função quando um ODBC *3.x* aplicativo está funcionando com um ODBC *2.x* driver, consulte [funções de mapeamento de substituição para trás Compatibilidade de aplicativos](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintaxe  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumentos  
 *StatementHandle*  
 [Entrada] Identificador de instrução.  
  
 *Atributo*  
 [Entrada] Opção de definir, listados em "Comentários".  
  
 *ValuePtr*  
 [Entrada] Valor a ser associado aos *atributo*. Dependendo do valor de *atributo*, *ValuePtr* será um dos seguintes:  
  
-   Um identificador de descritor ODBC.  
  
-   Um valor SQLUINTEGER.  
  
-   Um valor SQLULEN.  
  
-   Um ponteiro para um dos seguintes:  
  
    -   Uma cadeia de caracteres terminada em nulo.  
  
    -   Um buffer de binário.  
  
    -   Um valor ou uma matriz do tipo SQLLEN, SQLULEN ou SQLUSMALLINT.  
  
    -   Um valor definido pelo driver.  
  
 Se o *atributo* argumento é um valor específico do driver, *ValuePtr* pode ser um inteiro com sinal.  
  
 *StringLength*  
 [Entrada] Se *atributo* é um atributo definido pelo ODBC e *ValuePtr* aponta para uma cadeia de caracteres ou um buffer de binário, este argumento deve ser o comprimento da \* *ValuePtr*. Se *atributo* é um atributo definido pelo ODBC e *ValuePtr* é um inteiro *StringLength* será ignorado.  
  
 Se *atributo* é um atributo definido pelo driver, o aplicativo indica a natureza do atributo para o Gerenciador de Driver, definindo o *StringLength* argumento. *StringLength* pode ter os seguintes valores:  
  
-   Se *ValuePtr* é um ponteiro para uma cadeia de caracteres, em seguida, *StringLength* é o comprimento da cadeia de caracteres ou SQL_NTS.  
  
-   Se *ValuePtr* é um ponteiro para um buffer de binário, em seguida, o aplicativo coloca o resultado do SQL_LEN_BINARY_ATTR (*comprimento*) macro na *StringLength*. Isso coloca um valor negativo em *StringLength*.  
  
-   Se *ValuePtr* é um ponteiro para um valor diferente de uma cadeia de caracteres ou uma cadeia de caracteres binária, em seguida, *StringLength* deve ter o valor SQL_IS_POINTER.  
  
-   Se *ValuePtr* contiver um valor de comprimento fixo, então *StringLength* é SQL_IS_INTEGER ou SQL_IS_UINTEGER, conforme apropriado.  
  
## <a name="returns"></a>Retorna  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR ou SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnóstico  
 Quando **SQLSetStmtAttr** retorna SQL_ERROR ou SQL_SUCCESS_WITH_INFO, um valor SQLSTATE associado pode ser obtida chamando **SQLGetDiagRec** com um *HandleType* do SQL _HANDLE_STMT e uma *manipular* dos *StatementHandle*. A tabela a seguir lista os valores SQLSTATE normalmente retornados por **SQLSetStmtAttr** e explica cada uma no contexto dessa função; a notação "(DM)" precede as descrições das SQLSTATEs retornados pelo Gerenciador de Driver. O código de retorno associado com cada valor SQLSTATE é SQL_ERROR, a menos que indicado o contrário.  
  
|SQLSTATE|Erro|Descrição|  
|--------------|-----------|-----------------|  
|01000|Aviso geral|Mensagem informativa de específicos do driver. (A função retornará SQL_SUCCESS_WITH_INFO.)|  
|01S02|Valor de opção alterado|O driver não oferecia suporte para o valor especificado na *ValuePtr*, ou o valor especificado em *ValuePtr* era inválido devido a condições de trabalho de implementação, portanto, o driver substituído um valor semelhante. (**SQLGetStmtAttr** pode ser chamado para determinar o valor substituído temporariamente.) O valor de substituição é válido para o *StatementHandle* até que o cursor seja fechado, ponto em que o atributo de instrução será revertido para seu valor anterior. Os atributos de instrução que podem ser alterados são:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT  SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (A função retornará SQL_SUCCESS_WITH_INFO.)|  
|08S01|Falha de link de comunicação|Falha do link de comunicação entre o driver e a fonte de dados ao qual o driver foi conectado antes do processamento da função foi concluída.|  
|24000|Estado de cursor inválido|O *atributo* era SQL_ATTR_CURSOR_TYPE, SQL_ATTR_CONCURRENCY, SQL_ATTR_SIMULATE_CURSOR ou SQL_ATTR_USE_BOOKMARKS, e o cursor foi aberto.|  
|HY000|Erro geral|Ocorreu um erro para o qual não houve nenhum SQLSTATE específico e para o qual não foi definida nenhuma SQLSTATE específicos de implementação. A mensagem de erro retornada por **SQLGetDiagRec** na  *\*MessageText* buffer descreve o erro e sua causa.|  
|HY001|Erro de alocação de memória|O driver não pôde alocar a memória necessária para dar suporte à execução ou a conclusão da função.|  
|HY009|Uso inválido de ponteiro nulo|O *atributo* argumento identificado um atributo de instrução que é necessário um atributo de cadeia de caracteres, e o *ValuePtr* argumento é um ponteiro nulo.|  
|HY010|Erro de sequência de função|(DM) uma função de execução assíncrona foi chamada para o identificador de conexão que está associado a *StatementHandle*. Essa função assíncrona ainda estava em execução quando o **SQLSetStmtAttr** função foi chamada.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, ou **SQLMoreResults** foi chamado para o *StatementHandle* e retornado SQL_PARAM_DATA_ DISPONÍVEL. Essa função foi chamada antes de dados foram recuperados para todos os parâmetros transmitidos.<br /><br /> (DM) uma função de execução assíncrona foi chamada para o *StatementHandle* e ainda estava em execução quando essa função foi chamada.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, ou **SQLSetPos** foi chamado para o  *StatementHandle* e retornados de SQL_NEED_DATA. Essa função foi chamada antes de dados foi enviados para todos os parâmetros de dados em execução ou colunas.|  
|HY011|Atributo não pode ser definido agora|O *atributo* era SQL_ATTR_CONCURRENCY, SQL _ ATTR_CURSOR_TYPE, SQL _ ATTR_SIMULATE_CURSOR ou ATTR_USE_BOOKMARKS SQL _ e a instrução tiver sido preparada.|  
|HY013|Erro de gerenciamento de memória|A chamada de função não pôde ser processada porque os objetos de memória subjacente não pôde ser acessados, possivelmente devido a condições de memória insuficiente.|  
|HY017|Uso inválido de um identificador do descritor alocado automaticamente|(DM) a *atributo* argumento era SQL_ATTR_IMP_ROW_DESC ou SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) a *atributo* argumento era SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC e o valor na *ValuePtr* era um identificador do descritor implicitamente alocados que não seja o identificador originalmente alocados para a descartar ou APD.|  
|HY024|Valor de atributo inválido|Dado especificado *atributo* valor, um valor inválido foi especificado na *ValuePtr*. (O Gerenciador de Driver retorna esse SQLSTATE apenas para conexão e atributos de instrução que aceitam um conjunto discreto de valores, como SQL_ATTR_ACCESS_MODE ou ATTR_ASYNC_ENABLE SQL _. Para todas as outras conexão e atributos de instrução, o driver deve verificar o valor especificado na *ValuePtr*.)<br /><br /> O *atributo* argumento era SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, e *ValuePtr* era um identificador do descritor alocado explicitamente que não está na mesma conexão como o  *StatementHandle* argumento.|  
|HY090|Comprimento de buffer ou cadeia de caracteres inválido|(DM)  *\*ValuePtr* é uma cadeia de caracteres e o *StringLength* argumento era menor que 0 mas não estavam SQL_NTS.|  
|HY092|Identificador de atributo/opção inválido|(DM) o valor especificado para o argumento *atributo* não era válido para a versão do ODBC com suporte pelo driver.<br /><br /> (DM) o valor especificado para o argumento *atributo* era um atributo somente leitura.|  
|HY117|Conexão está suspenso devido ao estado de transação desconhecida. Somente se desconectar e funções de somente leitura são permitidas.|(DM) para obter mais informações sobre o estado suspenso, consulte [função SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Recurso opcional não implementado|O valor especificado para o argumento *atributo* foi um atributo de instrução ODBC válido para a versão do ODBC com suporte pelo driver, mas não tinha suporte pelo driver.<br /><br /> O *atributo* argumento era SQL_ATTR_ASYNC_ENABLE e uma chamada para **SQLGetInfo** com um *tipo de informação* de SQL_ASYNC_MODE retorna SQL_AM_CONNECTION.<br /><br /> O *atributo* argumento era SQL_ATTR_ENABLE_AUTO_IPD, e o valor do atributo de conexão SQL_ATTR_AUTO_IPD era SQL_FALSE.|  
|HYT01|Tempo limite da Conexão expirado|O período de tempo limite de conexão expirado antes que a fonte de dados respondeu à solicitação. O período de tempo limite de conexão é definido por meio **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Driver não oferece suporte a essa função|O driver em (DM) associado a *StatementHandle* não suporta a função.|  
|S1118|Driver não oferece suporte a notificação assíncrona|Se chamar **SQLSetStmtAttr** definir SQL_ATTR_ASYNC_STMT_EVENT; não há suporte para notificação assíncrona pelo driver.|  
  
## <a name="comments"></a>Comentários  
 Atributos de instrução para uma instrução permanecem em vigor até que eles são alterados por outra chamada para **SQLSetStmtAttr** ou até que a instrução seja descartada chamando **SQLFreeHandle**. Chamando **SQLFreeStmt** com o SQL_CLOSE, SQL_UNBIND ou SQL_RESET_PARAMS opção não redefine os atributos de instrução.  
  
 Alguns atributos de instrução oferecem suporte à substituição de um valor semelhante se a fonte de dados não dá suporte para o valor especificado na *ValuePtr*. Nesses casos, o driver retorna SQL_SUCCESS_WITH_INFO e SQLSTATE 01S02 (valor de opção alterado). Por exemplo, se *atributo* é SQL_ATTR_CONCURRENCY e *ValuePtr* é SQL_CONCUR_ROWVER, e se a fonte de dados não der suporte a isso, o driver substitui SQL_CONCUR_VALUES e retorna SQL _ SUCCESS_WITH_INFO. Para determinar o valor substituído, um aplicativo chama **SQLGetStmtAttr**.  
  
 O formato de informações definido com *ValuePtr* depende especificado *atributo*. **SQLSetStmtAttr** aceita informações de atributo em um dos dois formatos diferentes: uma cadeia de caracteres ou um valor inteiro. O formato de cada um é indicado na descrição do atributo. Esse formato se aplica às informações retornadas para cada atributo em **SQLGetStmtAttr**. Apontada por cadeias de caracteres a *ValuePtr* argumento de **SQLSetStmtAttr** ter um comprimento de *StringLength*.  
  
> [!NOTE]
>  A capacidade de definir atributos de instrução no nível de conexão chamando **SQLSetConnectAttr** foi preterido no ODBC *3.x*. ODBC *3.x* aplicativos nunca devem definir atributos de instrução no nível de conexão. ODBC *3.x* atributos de instrução não podem ser definidos no nível de conexão, com exceção dos atributos SQL_ATTR_METADATA_ID e SQL_ATTR_ASYNC_ENABLE, que são atributos de conexão e atributos de instrução e pode ser definido no nível de conexão ou o nível de instrução.  
> 
> [!NOTE]
>  ODBC *3.x* drivers precisam dar suporte apenas essa funcionalidade se eles devem trabalhar com ODBC *2.x* aplicativos que definam ODBC *2.x* opções da instrução no nível de conexão. Para obter mais informações, consulte "Configuração instrução opções sobre a Conexão nível sob" [mapeamento SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) no Apêndice g: Diretrizes de driver para compatibilidade com versões anteriores.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Atributos de instrução que definir campos de descritor  
 Muitos atributos de instrução correspondem a um campo de cabeçalho de um descritor. Definindo esses atributos, na verdade, os resultados na configuração dos campos de descritor. Definir campos por uma chamada para **SQLSetStmtAttr** vez **SQLSetDescField** tem a vantagem de um identificador do descritor não precisa ser obtido para a chamada de função.  
  
> [!CAUTION]  
>  Chamando **SQLSetStmtAttr** para uma instrução pode afetar outras instruções. Isso ocorre quando o APD ou descartar associados à instrução explicitamente é alocada e também está associado a outras instruções. Porque **SQLSetStmtAttr** modifica o APD ou descartar, as modificações se aplicam a todas as instruções ao qual esse descritor está associado. Se isso não é o comportamento necessário, o aplicativo deve desassociar Esse descritor de outras instruções (chamando **SQLSetStmtAttr** para definir o campo SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC para outro Identificador do descritor) antes de chamar **SQLSetStmtAttr** novamente.  
  
 Quando um campo de descritor é definido como resultado do atributo de instrução correspondente que está sendo definido, o campo é definido somente para os descritores de aplicáveis que estão atualmente associados com a instrução a identificado pelo *StatementHandle* argumento e a configuração do atributo não afeta qualquer descritores que podem estar associados essa instrução no futuro. Quando um campo de descritor que também é um atributo de instrução é definido por uma chamada para **SQLSetDescField**, o atributo de instrução correspondente é definido. Se um descritor alocado explicitamente é desassociado de uma instrução, um atributo de instrução que corresponde a um campo de cabeçalho será revertido para o valor do campo no descritor de implicitamente alocado.  
  
 Quando uma instrução é alocada (consulte [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quatro identificadores de descritor são alocados automaticamente e associadas à instrução. Podem ser associados à instrução identificadores de descritor alocado explicitamente chamando **SQLAllocHandle** com um *fHandleType* de SQL_HANDLE_DESC para alocar um identificador do descritor e, em seguida, chamar  **SQLSetStmtAttr** para associar o identificador do descritor de instrução.  
  
 Os atributos de instrução na tabela a seguir correspondem aos campos de cabeçalho do descritor.  
  
|atributo de instrução|Campo de cabeçalho|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|DESCARTAR|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|DESCARTAR|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|DESCARTAR|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|DESCARTAR|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Atributos de instrução  
 Os atributos definidos no momento e a versão do ODBC na qual eles foram introduzidos são mostrados na tabela a seguir; é esperado que serão definidos atributos mais pelos drivers para tirar proveito de diferentes fontes de dados. Um intervalo de atributos é reservado pelo ODBC; os desenvolvedores de driver deverá reservar os valores para seu próprio uso específico do driver do Open Group. Para obter mais informações, consulte [tipos de dados específicos do Driver, tipos de descritor, tipos de informação, tipos de diagnóstico e atributos](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|attribute|*ValuePtr* conteúdo|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|O identificador para o APD para chamadas posteriores às **SQLExecute** e **SQLExecDirect** no identificador da instrução. O valor inicial desse atributo é o descritor alocado implicitamente quando a instrução foi inicialmente alocada. Se o valor desse atributo é definido como SQL_NULL_DESC ou o identificador originalmente alocado para o descritor, um identificador APD explicitamente alocado que foi previamente associado com o identificador de instrução é dissociado dele e o identificador de instrução será revertido para o implicitamente alocados identificador APD.<br /><br /> Esse atributo não pode ser definido para um identificador do descritor que foi alocado implicitamente para outra instrução ou outro identificador do descritor que foi implicitamente definido na mesma instrução; identificadores de descritor alocado implicitamente não podem ser associados a mais de uma instrução ou o identificador do descritor.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|O identificador para a descartar para buscas subsequentes no identificador da instrução. O valor inicial desse atributo é o descritor alocado implicitamente quando a instrução foi inicialmente alocada. Se o valor desse atributo é definido como SQL_NULL_DESC ou o identificador originalmente alocado para o descritor, um identificador de descartar explicitamente alocado que foi previamente associado com o identificador de instrução é dissociado dele e o identificador de instrução será revertido para o implicitamente alocados identificador descartar.<br /><br /> Esse atributo não pode ser definido para um identificador do descritor que foi alocado implicitamente para outra instrução ou outro identificador do descritor que foi implicitamente definido na mesma instrução; identificadores de descritor alocado implicitamente não podem ser associados a mais de uma instrução ou o identificador do descritor.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Um valor SQLULEN que especifica se uma função chamada com a instrução especificada é executada de forma assíncrona:<br /><br /> SQL_ASYNC_ENABLE_OFF = suporte nível de execução assíncrona da instrução Disable (o padrão).<br /><br /> SQL_ASYNC_ENABLE_ON = Habilitar suporte de nível de execução assíncrona da instrução.<br /><br /> Para obter mais informações, consulte [execução assíncrona (método de sondagem)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Para os drivers com suporte de nível de execução assíncrona da instrução, o atributo de instrução SQL_ATTR_ASYNC_ENABLE é somente leitura. Seu valor é igual ao valor do atributo de nível de conexão com o mesmo nome no momento em que o identificador de instrução foi alocado.<br /><br /> Chamando **SQLSetStmtAttr** para definir SQL_ATTR_ASYNC_ENABLE quando o SQL_ASYNC_MODE *tipo de informação* retornará SQL_AM_CONNECTION retornará SQLSTATE HYC00 (recurso opcional não implementado). Para obter mais informações, consulte [função SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) para obter mais informações.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Um valor SQLPOINTER que é um identificador de eventos.<br /><br /> Notificação de conclusão de funções assíncronas está habilitada, chamando **SQLSetStmtAttr** para definir o **SQL_ATTR_ASYNC_STMT_EVENT** de atributos e especificar o identificador de evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Um SQLPOINTER para a função de retorno de chamada assíncrono.<br /><br /> Somente o Gerenciador de Driver pode chamar um driver **SQLSetStmtAttr** função com esse atributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Um SQLPOINTER para a estrutura de contexto<br /><br /> Somente o Gerenciador de Driver pode chamar um driver **SQLSetStmtAttr** função com esse atributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Um valor SQLULEN que especifica a simultaneidade de cursor:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor é somente leitura. Não são permitidas atualizações.<br /><br /> SQL_CONCUR_LOCK = Cursor usa o nível mais baixo de bloqueio suficiente para garantir que a linha pode ser atualizada.<br /><br /> SQL_CONCUR_ROWVER = controle de simultaneidade otimista de usos do Cursor, comparando as versões de linha como SQLBase ROWID ou Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = controle de simultaneidade otimista de usos do Cursor, comparar valores.<br /><br /> O valor padrão para SQL_ATTR_CONCURRENCY é SQL_CONCUR_READ_ONLY.<br /><br /> Esse atributo não pode ser especificado para um cursor aberto. Para obter mais informações, consulte [tipos de simultaneidade](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Se o SQL_ATTR_CURSOR_TYPE *atributo* é alterado para um tipo que não oferece suporte para o valor atual da SQL_ATTR_CONCURRENCY, o valor de SQL_ATTR_CONCURRENCY será alterado em tempo de execução e um aviso será emitido quando **SQLExecDirect** ou **SQLPrepare** é chamado.<br /><br /> Se o driver dá suporte a **SELECT FOR UPDATE** instrução e o tipo de instrução é executada enquanto o valor de SQL_ATTR_CONCURRENCY é definido como SQL_CONCUR_READ_ONLY, um erro será retornado. Se o valor de SQL_ATTR_CONCURRENCY é alterado para um valor que o driver dá suporte para algum valor de SQL_ATTR_CURSOR_TYPE, mas não para o valor atual da SQL_ATTR_CURSOR_TYPE, o valor de SQL_ATTR_CURSOR_TYPE será alterado em tempo de execução e 01S02 SQLSTATE (O valor de opção alterado) é emitido quando **SQLExecDirect** ou **SQLPrepare** é chamado.<br /><br /> Se não há suporte para a simultaneidade especificada pela fonte de dados, o driver substitui uma simultaneidade diferente e retorna um SQLSTATE 01S02 (valor de opção alterado). Para SQL_CONCUR_VALUES, o driver substitui SQL_CONCUR_ROWVER e vice-versa. Para SQL_CONCUR_LOCK, o driver substitui, em ordem, SQL_CONCUR_ROWVER ou SQL_CONCUR_VALUES. A validade do valor substituído não será verificada até o tempo de execução.<br /><br /> Para obter mais informações sobre a relação entre SQL_ATTR_CONCURRENCY e outros atributos de cursor, consulte [características do Cursor e tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Um valor SQLULEN que especifica o nível de suporte que o aplicativo requer. A configuração desse atributo afeta as chamadas subsequentes para **SQLExecDirect** e **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = rolável cursores não são necessários em identificador de instrução. Se o aplicativo chamar **SQLFetchScroll** neste identificador, o único valor válido *FetchOrientation* é SQL_FETCH_NEXT. Esse é o padrão.<br /><br /> SQL_SCROLLABLE = rolável cursores são necessárias no identificador de instrução. Ao chamar **SQLFetchScroll**, o aplicativo pode especificar qualquer valor válido de *FetchOrientation*, atingir o posicionamento do cursor em modos diferentes de modo sequencial.<br /><br /> Para obter mais informações sobre cursores roláveis, consulte [cursores roláveis](../../../odbc/reference/develop-app/scrollable-cursors.md). Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_SCROLLABLE e outros atributos de cursor, consulte [características do Cursor e tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Um valor SQLULEN que especifica se os cursores no identificador da instrução tornar visíveis as alterações feitas em um resultado definido por outro cursor. A configuração desse atributo afeta as chamadas subsequentes para **SQLExecDirect** e **SQLExecute**. Um aplicativo pode ler o valor desse atributo como obter seu estado inicial ou seu estado como mais recentemente definido pelo aplicativo.<br /><br /> SQL_UNSPECIFIED = não é especificado o que é o tipo de cursor e se os cursores no identificador da instrução tornar visíveis as alterações feitas em um conjunto de resultados por outro cursor. Cursores no identificador da instrução podem tornar visível nenhum, alguns ou todos os tais alterações. Esse é o padrão.<br /><br /> SQL_INSENSITIVE = todos os cursores em identificador de instrução mostrar o conjunto de resultados sem refletir quaisquer alterações feitas nele por qualquer outro cursor. Cursores sem distinção são somente leitura. Isso corresponde a um cursor estático, que tem uma simultaneidade que é somente leitura.<br /><br /> SQL_SENSITIVE = todos os cursores em que a marca de identificador de instrução visível todas as alterações feitas a um resultado definidas por outro cursor.<br /><br /> Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_SENSITIVITY e outros atributos de cursor, consulte [características do Cursor e tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Um valor SQLULEN que especifica o tipo de cursor:<br /><br /> SQL_CURSOR_FORWARD_ONLY = a cursor apenas rola para frente.<br /><br /> SQL_CURSOR_STATIC = os dados no resultado do conjunto é estático.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = o driver salva e usa as chaves para o número de linhas especificado no atributo de instrução SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = o driver salva e usa apenas as chaves para as linhas no conjunto de linhas.<br /><br /> O valor padrão é SQL_CURSOR_FORWARD_ONLY. Esse atributo não pode ser especificado após a instrução SQL foi preparada.<br /><br /> Se não há suporte para o tipo de cursor especificado pela fonte de dados, o driver substitui um tipo de cursor diferente e retornará SQLSTATE 01S02 (valor de opção alterado). Um cursor dinâmico ou misto, o driver substitui, em ordem, um cursor controlado por conjunto de chaves ou estático. Um cursor controlado por conjunto de chaves, o driver substitui um cursor estático.<br /><br /> Para obter mais informações sobre os tipos de cursor rolável, consulte [tipos de Cursor rolável](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_TYPE e outros atributos de cursor, consulte [características do Cursor e tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Um valor SQLULEN que especifica se a população automática do IPD é executada:<br /><br /> SQL_TRUE = ativa na população automática do IPD após uma chamada para **SQLPrepare**. SQL_FALSE = desativa desativado população automática do IPD após uma chamada para **SQLPrepare**. (Um aplicativo ainda pode obter informações de campo IPD chamando **SQLDescribeParam**, se houver suporte.) O valor padrão do atributo de instrução SQL_ATTR_ENABLE_AUTO_IPD é SQL_FALSE. Para obter mais informações, consulte [população automática do IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Um SQLLEN \* que aponta para um valor de indicador binário. Quando **SQLFetchScroll** for chamado com *fFetchOrientation* igual a SQL_FETCH_BOOKMARK, o driver pega o valor de indicador desse campo. Este campo assume um ponteiro nulo. Para obter mais informações, consulte [rolando pelo indicador](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> O valor apontado por este campo não é usado para a exclusão pelo indicador, atualizar pelo indicador ou buscar por operações de indicador na **SQLBulkOperations**, que usam os indicadores armazenados em cache nos buffers de conjunto de linhas.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|O identificador para o IPD. O valor desse atributo é o descritor alocado quando a instrução foi inicialmente alocada. O aplicativo não é possível definir esse atributo.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|O identificador para o IRD. O valor desse atributo é o descritor alocado quando a instrução foi inicialmente alocada. O aplicativo não é possível definir esse atributo.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Um SQLULEN que especifica o número de linhas no conjunto de chaves para um cursor controlado por conjunto de chaves. Se o tamanho do conjunto de chaves for 0 (o padrão), o cursor é totalmente controlado por conjunto de chaves. Se o tamanho do conjunto de chaves for maior que 0, o cursor é misto (controlado por dentro do conjunto de chaves e dinâmico fora do conjunto de chaves). O tamanho do conjunto de chaves padrão é 0. Para obter mais informações sobre cursores controlados por conjunto de chaves, consulte [Keyset-Driven cursores](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Se o tamanho especificado excede o tamanho máximo do conjunto de chaves, o driver substitui esse tamanho e retornará SQLSTATE 01S02 (valor de opção alterado).<br /><br /> **SQLFetch** ou **SQLFetchScroll** retornará um erro se o tamanho do conjunto de chaves é maior que 0 e menor que o tamanho do conjunto de linhas.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Um valor SQLULEN que especifica a quantidade máxima de dados que o driver retorna de um caractere ou uma coluna binária. Se *ValuePtr* é menor que o comprimento dos dados disponíveis, **SQLFetch** ou **SQLGetData** truncará os dados e retorna SQL_SUCCESS. Se *ValuePtr* é 0 (o padrão), o driver tenta retornar todos os dados disponíveis.<br /><br /> Se o comprimento especificado é menor que a quantidade mínima de dados que a fonte de dados pode retornar ou maior que a quantidade máxima de dados que pode retornar a fonte de dados, substitui o driver que valor e retorna um SQLSTATE 01S02 (valor de opção alterado).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; No entanto, a configuração talvez não entram em vigor imediatamente, em cujo caso o driver retornará SQLSTATE 01S02 (valor de opção alterado) e redefina o atributo para seu valor original.<br /><br /> Esse atributo destina-se para reduzir o tráfego de rede e deve ser suportado apenas quando a fonte de dados (em vez de driver) em um driver de várias camadas pode implementá-lo. Esse mecanismo não deve ser usado por aplicativos para truncar os dados; para truncar os dados recebidos, um aplicativo deve especificar o comprimento máximo do buffer na *BufferLength* argumento **SQLBindCol** ou **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Um valor SQLULEN correspondente para o número máximo de linhas a serem retornadas para o aplicativo para um **selecionar** instrução. Se \* *ValuePtr* é igual a 0 (o padrão), o driver retornará todas as linhas.<br /><br /> Esse atributo destina-se para reduzir o tráfego de rede. Conceitualmente, ela é aplicada quando o conjunto de resultados é criado e limita o conjunto de resultados para o primeiro *ValuePtr* linhas. Se o número de linhas no conjunto de resultados for maior que *ValuePtr*, o conjunto de resultados será truncado.<br /><br /> SQL_ATTR_MAX_ROWS se aplica a todos os conjuntos de resultados sobre o *instrução*, inclusive as retornadas por funções de catálogo. SQL_ATTR_MAX_ROWS estabelece um máximo para o valor da contagem de linha do cursor.<br /><br /> Um driver não deve emular o comportamento SQL_ATTR_MAX_ROWS para **SQLFetch** ou **SQLFetchScroll** (se as limitações de tamanho de conjunto de resultados não podem ser implementadas na fonte de dados) se ele não pode garantir que sql_attr MAX_ROWS será implementada corretamente.<br /><br /> Ele é definido pelo driver se SQL_ATTR_MAX_ROWS se aplica a instruções que não sejam instruções SELECT (como funções de catálogo).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; No entanto, a configuração talvez não entram em vigor imediatamente, em cujo caso o driver retornará SQLSTATE 01S02 (valor de opção alterado) e redefina o atributo para seu valor original.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Um valor SQLULEN que determina como os argumentos de cadeia de caracteres das funções de catálogo são tratados.<br /><br /> Se SQL_TRUE, o argumento de cadeia de caracteres das funções de catálogo são tratadas como identificadores. Caso não é significativo. Para cadeias de caracteres proibidas, o driver remove os espaços à direita e a cadeia de caracteres é armazenada em maiusculas. Para cadeias de caracteres delimitadas, o driver remove espaços à esquerda ou à direita e usa tudo o que está entre os delimitadores literalmente. Se um desses argumentos é definido como um ponteiro nulo, a função retornará SQL_ERROR e SQLSTATE HY009 (uso inválido de ponteiro nulo).<br /><br /> Se SQL_FALSE, os argumentos de cadeia de caracteres das funções de catálogo não são tratadas como identificadores. O caso é significativo. Eles podem conter um padrão de pesquisa de cadeia de caracteres ou não, dependendo do argumento.<br /><br /> O valor padrão é SQL_FALSE.<br /><br /> O *TableType* argumento de **SQLTables**, que usa uma lista de valores, não é afetada por este atributo.<br /><br /> SQL_ATTR_METADATA_ID também podem ser definidas no nível de conexão. (Ele e SQL_ATTR_ASYNC_ENABLE são os atributos de instrução única que também são atributos de conexão).<br /><br /> Para obter mais informações, consulte [argumentos em funções de catálogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Um valor SQLULEN que indica se o driver deve verificar as cadeias de caracteres SQL para sequências de escape:<br /><br /> SQL_NOSCAN_OFF = as verificações de driver cadeias de caracteres SQL para sequências de escape (o padrão).<br /><br /> SQL_NOSCAN_ON = o driver não verifica cadeias de caracteres SQL para sequências de escape. Em vez disso, o driver envia a instrução diretamente à fonte de dados.<br /><br /> Para obter mais informações, consulte [sequências de Escape no ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Um SQLULEN * valor aponta para um deslocamento adicionado para ponteiros para alterar a associação de parâmetros dinâmicos. Se esse campo não for nulo, o driver cancelará o ponteiro, adicionará o valor cancelado a cada um dos campos adiados no registro do descritor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usa os novos valores de ponteiro durante a associação. Ele é definido como null por padrão.<br /><br /> O deslocamento de ligação sempre é adicionado diretamente para os campos SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR. Se o deslocamento for alterado para um valor diferente, o novo valor é adicionado diretamente ao valor no campo de descritor. O novo deslocamento não é adicionado a qualquer deslocamento anterior além do valor do campo.<br /><br /> Para obter mais informações, consulte [deslocamentos de associação de parâmetro](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_BIND_OFFSET_PTR no cabeçalho APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Um valor SQLULEN que indica a orientação de associação a ser usado para parâmetros dinâmicos.<br /><br /> Esse campo é definido como SQL_PARAM_BIND_BY_COLUMN (o padrão) para selecionar a associação por coluna.<br /><br /> Para selecionar a associação por linha, esse campo é definido como o tamanho da estrutura ou uma instância de um buffer que será associado a um conjunto de parâmetros dinâmicos. Esse comprimento deve incluir espaço para todos os parâmetros associados e qualquer preenchimento da estrutura ou do buffer para garantir que, quando o endereço de um parâmetro associado é incrementado com o comprimento especificado, o resultado apontará para o início do mesmo parâmetro nos próximos conjunto de parâmetros. Ao usar o *sizeof* operador em ANSI C, esse comportamento é garantido.<br /><br /> Para obter mais informações, consulte [associando matrizes de parâmetros](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ BIND_TYPE no cabeçalho APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Um SQLUSMALLINT \* valor que aponta para uma matriz de valores SQLUSMALLINT usado para ignorar um parâmetro durante a execução de uma instrução SQL. Cada valor é definido como SQL_PARAM_PROCEED (para o parâmetro a ser executado) ou SQL_PARAM_IGNORE (para o parâmetro a serem ignorados).<br /><br /> Um conjunto de parâmetros pode ser ignorado durante o processamento, definindo o valor de status na matriz apontada por SQL_DESC_ARRAY_STATUS_PTR no APD para SQL_PARAM_IGNORE. Um conjunto de parâmetros é processado se o valor do status é definido como SQL_PARAM_PROCEED ou se nenhum elemento na matriz é definido.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro nulo, nesse caso o driver não retorna parâmetro valores de status. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez **SQLExecDirect** ou **SQLExecute** é chamado.<br /><br /> Esse atributo é ignorado quando não há nenhum parâmetro associado.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Um SQLUSMALLINT \* que contém informações de status para cada linha de valores de parâmetro após uma chamada para valores de valor que aponta para uma matriz de SQLUSMALLINT **SQLExecute** ou **SQLExecDirect**. Esse campo é obrigatório apenas se PARAMSET_SIZE for maior que 1.<br /><br /> Os valores de status podem conter os seguintes valores:<br /><br /> SQL_PARAM_SUCCESS: A instrução SQL foi executada com êxito para esse conjunto de parâmetros.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: A instrução SQL foi executada com êxito para esse conjunto de parâmetros. No entanto, informações de aviso estão disponíveis na estrutura de dados de diagnóstico.<br /><br /> SQL_PARAM_ERROR: Ocorreu um erro ao processar este conjunto de parâmetros. Informações de erro adicionais estão disponíveis na estrutura de dados de diagnóstico.<br /><br /> SQL_PARAM_UNUSED: Esse conjunto de parâmetros foi não utilizado, possivelmente devido ao fato de que algum conjunto de parâmetros anteriores causou um erro que anulado processamento adicional ou porque SQL_PARAM_IGNORE foi definido para esse conjunto de parâmetros da matriz especificado pelo SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: O driver trata as matrizes de parâmetros como uma unidade monolítica e portanto, não gera esse nível de informações de erro.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro nulo, nesse caso o driver não retorna parâmetro valores de status. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez **SQLExecute** ou **SQLExecDirect** é chamado. Observe que a configuração deste atributo pode afetar o comportamento do parâmetro de saída implementado pelo driver.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho do IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Um SQLULEN \* campos de registro que aponta para um buffer no qual retornar o número de conjuntos de parâmetros que foram processados, incluindo conjuntos de erro. Nenhum número será retornado se esse for um ponteiro nulo.<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ROWS_PROCESSED_PTR no cabeçalho do IPD.<br /><br /> Se a chamada para **SQLExecDirect** ou **SQLExecute** que preenche o buffer apontado por este atributo não retorna SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, o conteúdo do buffer é indefinido.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Um valor SQLULEN que especifica o número de valores para cada parâmetro. Se SQL_ATTR_PARAMSET_SIZE for maior que 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR do ponto de APD a matrizes. A cardinalidade de cada matriz é igual ao valor desse campo.<br /><br /> Esse atributo é ignorado quando não há nenhum parâmetro associado.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ARRAY_SIZE no cabeçalho APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Um valor SQLULEN correspondente ao número de segundos de espera de uma instrução SQL executar antes de retornar ao aplicativo. Se *ValuePtr* é igual a 0 (padrão), não há nenhum tempo limite.<br /><br /> Se o tempo limite especificado excede o tempo limite máximo na fonte de dados ou é menor do que o tempo limite mínimo, **SQLSetStmtAttr** substitui esse valor e retorna um SQLSTATE 01S02 (valor de opção alterado).<br /><br /> Observe que o aplicativo não precisa chamar **SQLCloseCursor** reutilizar a instrução se um **selecione** instrução atingiu o tempo limite.<br /><br /> O tempo limite da consulta definido neste atributo de instrução é válido em modos síncronos e assíncronos.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Um valor SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** e, no ODBC *3.x*, **SQLFetch** recuperar dados depois que ela posiciona o cursor no local especificado. Esse é o padrão.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** e, no ODBC *3.x*, **SQLFetch** não recuperar os dados depois que ela posiciona o cursor.<br /><br /> Definindo SQL_RETRIEVE_DATA como SQL_RD_OFF, um aplicativo pode verificar que uma linha existe ou recuperar um indicador para a linha sem incorrer na sobrecarga de recuperar linhas. Para obter mais informações, consulte [rolagem e busca linhas](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; No entanto, a configuração talvez não entram em vigor imediatamente, em cujo caso o driver retornará SQLSTATE 01S02 (valor de opção alterado) e redefina o atributo para seu valor original.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Um valor SQLULEN que especifica o número de linhas retornado por cada chamada para **SQLFetch** ou **SQLFetchScroll**. Também é o número de linhas em uma matriz de indicador usado em uma operação de indicador em massa no **SQLBulkOperations**. O valor padrão é 1.<br /><br /> Se o tamanho do conjunto de linhas especificado excede o tamanho máximo do conjunto de linhas com suporte pela fonte de dados, o driver substitui esse valor e retorna um SQLSTATE 01S02 (valor de opção alterado).<br /><br /> Para obter mais informações, consulte [tamanho de conjunto de linhas](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ARRAY_SIZE no cabeçalho descartar.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Um SQLULEN * valor aponta para um deslocamento adicionado para ponteiros para alterar a associação de dados de coluna. Se esse campo não for nulo, o driver cancelará o ponteiro, adicionará o valor cancelado a cada um dos campos adiados no registro do descritor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usa os novos valores de ponteiro durante a associação. Ele é definido como null por padrão.<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_BIND_OFFSET_PTR no cabeçalho descartar.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Um valor SQLULEN que define a orientação de associação a ser usado quando **SQLFetch** ou **SQLFetchScroll** é chamado na instrução associada. A associação é selecionada, definindo o valor como SQL_BIND_BY_COLUMN. A associação é selecionada, definindo o valor para o comprimento de uma estrutura ou uma instância de um buffer no qual as colunas de resultados serão associadas.<br /><br /> Se um comprimento for especificado, ele deve incluir espaço para todas as colunas associadas e qualquer preenchimento da estrutura ou do buffer para garantir que, quando o endereço de uma coluna associada for incrementado com o comprimento especificado, o resultado apontará para o início da mesma coluna na th e a próxima linha. Ao usar o **sizeof** operador com estruturas ou uniões em ANSI C, esse comportamento é garantido.<br /><br /> A associação é a orientação de associação padrão para **SQLFetch** e **SQLFetchScroll**.<br /><br /> Para obter mais informações, consulte [colunas de associação para uso com cursores em bloco](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_BIND_TYPE no cabeçalho descartar.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Um valor SQLULEN é o número da linha atual em todo o resultado definido. Se o número da linha atual não pode ser determinado ou se não há nenhuma linha atual, o driver retornará 0.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** mas não definido por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Um SQLUSMALLINT \* valor que aponta para uma matriz de valores SQLUSMALLINT usado para ignorar uma linha durante uma operação em massa usando **SQLSetPos**. Cada valor é definido como SQL_ROW_PROCEED (para a linha a ser incluído na operação em massa) ou SQL_ROW_IGNORE (para a linha a serem excluídos da operação em massa). (Linhas não podem ser ignoradas usando essa matriz durante as chamadas para **SQLBulkOperations**.)<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro nulo, nesse caso o driver não retorna valores de status de linha. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez **SQLSetPos** é chamado.<br /><br /> Para obter mais informações, consulte [atualizando linhas no conjunto de linhas com SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) e [excluindo linhas no conjunto de linhas com SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR na descartar.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Um SQLUSMALLINT \* valor que aponta para uma matriz de SQLUSMALLINT valores contendo valores de status de linha após uma chamada para **SQLFetch** ou **SQLFetchScroll**. A matriz tem o máximo de elementos existem linhas no conjunto de linhas.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro nulo, nesse caso o driver não retorna valores de status de linha. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, ou  **SQLSetPos** é chamado.<br /><br /> Para obter mais informações, consulte [número de linhas buscadas e Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho do IRD.<br /><br /> Esse atributo é mapeado por um ODBC *2.x* driver para o *rgbRowStatus* matriz em uma chamada para **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Um SQLULEN \* valor que aponta para um buffer no qual retornar o número de linhas buscadas após uma chamada para **SQLFetch** ou **SQLFetchScroll**; o número de linhas afetadas por uma operação em massa executada por uma chamada para **SQLSetPos** com um *operação* argumento de SQL_REFRESH; ou o número de linhas afetadas por uma operação em massa executada pelo **SQLBulkOperations**. Esse número inclui linhas de erro.<br /><br /> Para obter mais informações, consulte [número de linhas buscadas e Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Definir esse atributo de instrução define o campo SQL_DESC_ROWS_PROCESSED_PTR no cabeçalho do IRD.<br /><br /> Se a chamada para **SQLFetch** ou **SQLFetchScroll** que preenche o buffer apontado por este atributo não retorna SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, o conteúdo do buffer é indefinido.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Um valor SQLULEN que especifica se drivers que simulam posicionados instruções update e delete garante que tais instruções afetam apenas uma única linha.<br /><br /> Para simular a atualização posicionadas e instruções delete, a maioria dos drivers construir um pesquisada **atualize** ou **excluir** instrução que contém uma **onde** cláusula que especifica o valor de cada coluna na linha atual. A menos que essas colunas compõem uma chave exclusiva, tal afirmação pode afetar mais de uma linha.<br /><br /> Para garantir que essas instruções afetam apenas uma linha, o driver determina as colunas em uma chave exclusiva e adiciona essas colunas para o conjunto de resultados. Se um aplicativo garante que as colunas no conjunto de resultados compõem uma chave exclusiva, o driver não é necessário para fazer isso. Isso pode reduzir o tempo de execução.<br /><br /> SQL_SC_NON_UNIQUE = o driver garante que simulada posicionado atualização ou instruções delete afetarão apenas uma linha; é responsabilidade do aplicativo para fazer isso. Se uma instrução afetar mais de uma linha, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retornará SQLSTATE 01001 (conflito de operação do Cursor).<br /><br /> SQL_SC_TRY_UNIQUE = as tentativas de driver para garantir que simulada posicionado atualização ou exclusão instruções afetam apenas uma linha. O driver sempre executa essas instruções, mesmo se eles podem afetar mais de uma linha, por exemplo, quando não há nenhuma chave exclusiva. Se uma instrução afetar mais de uma linha, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retornará SQLSTATE 01001 (conflito de operação do Cursor).<br /><br /> SQL_SC_UNIQUE = as garantias de driver simulada atualização posicionada ou excluir instruções afetam apenas uma linha. Se o driver não pode garantir isso para uma determinada instrução, **SQLExecDirect** ou **SQLPrepare** retornará um erro.<br /><br /> Se a fonte de dados fornece SQL nativo oferece suporte a atualização posicionada e instruções delete e o driver não simula cursores, SQL_SUCCESS é retornado quando SQL_SC_UNIQUE for solicitado para SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO será retornado se SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE é solicitado. Se a fonte de dados fornece o nível SQL_SC_TRY_UNIQUE de suporte e o driver não, SQL_SUCCESS é retornado para SQL_SC_TRY_UNIQUE e SQL_SUCCESS_WITH_INFO será retornado para SQL_SC_NON_UNIQUE.<br /><br /> Se não há suporte para o tipo de simulação do cursor especificado pela fonte de dados, o driver substitui um tipo diferente de simulação e retornará SQLSTATE 01S02 (valor de opção alterado). Para SQL_SC_UNIQUE, o driver substitui, em ordem, SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE. Para SQL_SC_TRY_UNIQUE, o driver substitui SQL_SC_NON_UNIQUE.<br /><br /> O padrão é SQL_SC_UNIQUE.<br /><br /> Para obter mais informações, consulte [simulando posicionado instruções Update e excluir](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Um valor SQLULEN que especifica se um aplicativo irá usar indicadores com um cursor:<br /><br /> SQL_UB_OFF = desativado (padrão)<br /><br /> SQL_UB_VARIABLE = um aplicativo irá usar indicadores com um cursor, e o driver fornecerá indicadores de comprimento variável se eles têm suporte. SQL_UB_FIXED foi preterido no ODBC *3.x*. ODBC *3.x* aplicativos sempre devem usar indicadores de comprimento variável, mesmo ao trabalhar com ODBC *2.x* drivers (que tem suporte apenas de 4 bytes, de comprimento fixo de indicadores). Isso ocorre porque um indicador de comprimento fixo é apenas um caso especial de um indicador de comprimento variável. Ao trabalhar com ODBC *2.x* driver, o Gerenciador de Driver mapeia SQL_UB_VARIABLE para SQL_UB_FIXED.<br /><br /> Para utilizar indicadores com um cursor, o aplicativo deve especificar esse atributo com o valor SQL_UB_VARIABLE antes de abrir o cursor.<br /><br /> Para obter mais informações, consulte [recuperando indicadores](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] dessas funções podem ser chamadas de forma assíncrona somente se o descritor é um descritor de implementação, não um descritor de aplicativo.  
  
 Ver [a associação por coluna](../../../odbc/reference/develop-app/column-wise-binding.md) e [associação por linha](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funções relacionadas  
  
|Para obter informações sobre|Consulte|  
|---------------------------|---------|  
|Cancelando o processamento de instrução|[Função SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Retornando a configuração de um atributo de conexão|[Função SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Retornando a configuração de um atributo de instrução|[Função SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Definir um atributo de conexão|[Função SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Configuração de um único campo do descritor de|[Função SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Consulte também  
 [Referência da API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Arquivos de cabeçalho ODBC](../../../odbc/reference/install/odbc-header-files.md)
