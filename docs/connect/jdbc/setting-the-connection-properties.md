---
title: Configuração das propriedades de conexão | Microsoft Docs
ms.custom: ''
ms.date: 01/29/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
ms.assetid: f1b62700-f046-488d-bd6b-a5cd8fc345b7
author: MightyPen
ms.author: genemi
manager: jroth
ms.openlocfilehash: 60f1246fc26f96ff0aa65f9edef86643ad288150
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MTE75
ms.contentlocale: pt-BR
ms.lasthandoff: 06/15/2019
ms.locfileid: "66797824"
---
# <a name="setting-the-connection-properties"></a>Definindo as propriedades de conexão

[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

As propriedades da cadeia de conexão podem ser especificadas de várias formas:

- Como as propriedades name=value na URL de conexão quando você conecta usando a classe DriverManager.
- Como nome = value properties na *propriedades* parâmetro do método Connect da classe de Gerenciador de driver.
- Como valores no método setter apropriado da fonte de dados do driver. Por exemplo:  
  
    ```java
    datasource.setServerName(value)  
    datasource.setDatabaseName(value)  
    ```  
  
## <a name="remarks"></a>Remarks

Os nomes de propriedade não diferenciam maiúsculas de minúsculas, e os nomes de propriedade duplicados são resolvidos na seguinte ordem:  
  
1. Argumentos de API (como usuário e senha)
2. Coleção de propriedades.  
3. Última instância na cadeia de conexão.
  
Além disso, são permitidos valores desconhecidos para os nomes de propriedade, e os valores não são validados pelo driver JDBC para diferenciação de maiúsculas de minúsculas.

São permitidos sinônimos, resolvidos na ordem, assim como nomes de propriedade duplicados.

A tabela a seguir lista todas as propriedades da cadeia de conexão disponíveis no momento para o driver JDBC.

| Propriedade<br/>Tipo<br/>Padrão | Descrição |
| :------------------------------ | :---------- |
| accessToken<br/><br/>Cadeia de caracteres<br/><br/>nulo | Use essa propriedade para se conectar ao banco de dados SQL usando um token de acesso. **accessToken** não pode ser definida usando a URL de conexão. |
| applicationIntent<br/><br/>Cadeia de caracteres<br/><br/>ReadWrite | Declara o tipo de carga de trabalho de aplicativo ao conectar-se a um servidor. <br/><br/>Os valores possíveis são **ReadOnly** e **ReadWrite**. <br/><br/>Para saber mais, confira [Suporte do JDBC Driver para Alta disponibilidade, Recuperação de desastres](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md). |
| applicationName<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | O nome do aplicativo ou "[!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]" se nenhum nome tiver sido fornecido.<br/><br/>Usado para identificar o aplicativo específico em várias ferramentas de criação de perfil e de registro em log do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. |
| autenticação<br/><br/>Cadeia de caracteres<br/><br/>NotSpecified | Começando com o Microsoft JDBC Driver 6.0 para SQL Server, essa propriedade opcional indica qual método de autenticação do SQL a ser usado para conexão. Os valores possíveis são **ActiveDirectoryIntegrated**, **ActiveDirectoryPassword**, **ActiveDirectoryMSI**, **SqlPassword**e o padrão **NotSpecified**.<br/><br/> Use **ActiveDirectoryIntegrated** para se conectar ao banco de dados SQL usando a autenticação integrada do Windows.<br/><br/> Use **ActiveDirectoryPassword** para se conectar ao banco de dados SQL usando um nome de entidade de segurança do Azure AD e a senha.<br/><br/> Use **ActiveDirectoryMSI** para se conectar a um banco de dados SQL dentro de um recurso do Azure, por exemplo, uma máquina Virtual do Azure, serviço de aplicativo ou aplicativo de funções usando a autenticação de identidade de serviço gerenciado (MSI). <br><br>Os dois tipos de identidades gerenciadas com suporte pelo driver ao usar **ActiveDirectoryMSI** modo de autenticação são: <br> 1. _Atribuído pelo sistema identidade gerenciada_: usado para adquirir **accessToken** por padrão. <br> 2. _Identidade gerenciada de usuário atribuído_: usado para adquirir **accessToken** se a ID do cliente de uma identidade de serviço gerenciado (MSI) é especificada com o **msiClientId** propriedade de conexão.<br/><br/> Use **SqlPassword** para se conectar a um SQL Server usando **nome de usuário**/**usuário** e **senha** propriedades.<br/><br/> Use **NotSpecified** se nenhum desses métodos de autenticação são necessárias.<br/><br/> **Importante:** se a autenticação está definida como ActiveDirectoryIntegrated, as duas bibliotecas a seguir precisam ser instalados: **SQLJDBC_AUTH. DLL** (disponível no pacote de driver JDBC) e o Azure Active Directory Authentication Library para SQL Server (**ADALSQL. DLL**) está disponível em idiomas diferentes (para x86 e amd64) no Centro de download da [Microsoft Active Directory Authentication Library para Microsoft SQL Server](https://www.microsoft.com/download/details.aspx?id=48742). O driver JDBC dá suporte apenas à versão **1.0.2028.318 e superior** para o ADALSQL. DLL.<br/><br/> **Observação:** quando a autenticação propriedade é definida como qualquer valor diferente de **NotSpecified**, o driver por padrão usa criptografia Secure Sockets Layer (SSL).<br/><br/> Para obter informações sobre como configurar a autenticação do Active Directory do Azure, visite [conectar-se ao SQL banco de dados usando Azure Active Directory a autenticação](https://azure.microsoft.com/documentation/articles/sql-database-aad-authentication/). |
| authenticationScheme<br/><br/>Cadeia de caracteres<br/><br/>NativeAuthentication | Indica que tipo de segurança integrada você deseja que o seu aplicativo use. Os valores possíveis são **JavaKerberos** e o padrão **NativeAuthentication**.<br/><br/> Ao usar **authenticationScheme = JavaKerberos**, você deve especificar o nome de domínio totalmente qualificado (FQDN) na **serverName** ou **serverSpn** propriedade. Caso contrário, ocorrerá um erro (Servidor não encontrado no banco de dados de Kerberos).<br/><br/> Para obter mais informações sobre o uso do **authenticationScheme**, confira [Como usar a autenticação integrada do Kerberos para se conectar ao SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). |
| cancelQueryTimeout<br/><br/>INT<br/><br/>-1 | Começando com o Microsoft JDBC Driver 6.4 para SQL Server, essa propriedade pode ser usada para cancelar **queryTimeout** ativada a conexão. Execução de consultas para de responder e não gera exceção se a conexão TCP para o SQL Server for descartada silenciosamente. Essa propriedade só é aplicável se 'queryTimeout' também é ativada a conexão. <br/><br/>A quantidade total de espera que o driver **cancelQueryTimeout** + **queryTimeout** segundos, para remover a conexão e feche o canal. <br/><br/>O valor padrão desta propriedade é -1 e o comportamento é aguardar indefinidamente. |
| columnEncryptionSetting<br/><br/>Cadeia de caracteres<br/>["Habilitado" &#124; "Desabilitado"]<br/><br/>Desabilitado | Definido como "Habilitado" para usar o início do recurso AE (Always Encrypted) com o Microsoft JDBC Driver 6.0 para o SQL Server. Quando AE está habilitado, o driver JDBC criptografa e descriptografa os dados confidenciais armazenados em colunas de banco de dados criptografado no SQL Server.<br/><br/> Para obter mais informações sobre **columnEncryptionSetting**, consulte [usando o Always Encrypted com o Driver JDBC](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md) para obter mais detalhes.<br/><br/> **Observação:** Always Encrypted está disponível com o SQL Server 2016 ou versões posteriores. |
| databaseName,<br/>Banco de Dados<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | O nome do banco de dados ao qual se conectar. <br/><br/>Se não for indicada, será estabelecida uma conexão com o banco de dados padrão. |
| disableStatementPooling<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | Sinalizador que indica se o pool de instrução deve ser usado. |
| enablePrepareOnFirst...<br/>PreparedStatementCall<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | _enablePrepareOnFirstPreparedStatementCall_<br/><br/> Defina como "true" para habilitar a criação de identificador de instrução preparada chamando <code>sp_prepexec</code> na primeira execução da instrução preparada. <br/><br/>Definido como "false" para alterar a primeira execução de uma instrução preparada para chamar <code>sp_executesql</code> e não prepara uma instrução, depois que a segunda execução acontece, ele chamaria <code>sp_prepexec</code> para configurar um identificador de instrução preparada. |
| encrypt<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | Definido como "true" para especificar que o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] usa criptografia do protocolo SSL em todos os dados enviados entre o cliente e o servidor, caso este tenha um certificado instalado. O valor padrão é "falso".<br/><br/> Começando com o Microsoft JDBC Driver 6.0 para SQL Server, há uma nova conexão configuração 'authentication' que usa criptografia SSL por padrão. <br/><br/>Para obter mais informações, veja a propriedade 'autenticação'. |
| failoverPartner<br/><br/>Cadeia de caracteres<br/><br/>nulo | O nome do servidor de failover usado em uma configuração de espelhamento de banco de dados. Essa propriedade é usada em uma falha de conexão inicial ao servidor principal; depois que você estabelecer a conexão inicial, essa propriedade será ignorada. Ele deve ser usado com a propriedade databaseName.<br/><br/> **Observação:** o driver não dá suporte à especificação do número da porta de instância do servidor para a instância do parceiro de failover como parte da propriedade failoverPartner na cadeia de conexão. No entanto, há suporte à especificação das propriedades serverName, instanceName e portNumber da instância do servidor principal e da propriedade failoverPartner da instância do parceiro de failover na mesma cadeia de conexão.<br/><br/> Se você especificar um Nome de Rede Virtual na propriedade de conexão **Server**, não poderá usar o espelhamento de bancos de dados. Para saber mais, confira [Suporte do JDBC Driver para Alta disponibilidade, Recuperação de desastres](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) |
| fips<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>"false" | Para FIPS habilitada da JVM para essa propriedade deve ser **verdadeira**. |
| fipsProvider<br/><br/>Cadeia de caracteres<br/><br/>nulo | Provedor FIPS configurado na JVM. Por exemplo, BCFIPS ou SunPKCS11 NSS. Removido na versão 6.4.0 - consulte os detalhes [aqui](https://github.com/Microsoft/mssql-jdbc/pull/460). |
| gsscredential<br/><br/>org.ietf.jgss.GSSCredential<br/><br/>nulo | Começando com o Microsoft JDBC Driver 6.2 para SQL Server, as credenciais do usuário a ser usada para delegação restrita de Kerberos podem ser passadas nesta propriedade. <br/><br/>Isso deve ser usado com **integratedSecurity** como **verdadeiro** e **JavaKerberos** **authenticationscheme**. |
| hostNameInCertificate<br/><br/>Cadeia de caracteres<br/><br/>nulo | O nome do host a ser usado durante a validação do certificado SSL do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].<br/><br/> Se a propriedade hostNameInCertificate não for especificada ou estiver definida como nula, o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] usará o valor da propriedade **serverName** na URL de conexão como o nome do host para validar o certificado SSL do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].<br/><br/> **Observação:** essa propriedade é usada em combinação com o **criptografar**/**autenticação** propriedades e o **trustServerCertificate** propriedade. Essa propriedade afetará a validação do certificado se e somente se a conexão usa criptografia Secure Sockets Layer (SSL) e o **trustServerCertificate** é definido como "false". Verifique se o valor passado para **hostNameInCertificate** corresponde exatamente ao CN (Nome Comum) ou ao nome DNS no SAN (Nome Alternativo da Entidade) no certificado do servidor para que uma conexão SSL tenha êxito. Para obter mais informações, consulte [Noções básicas sobre suporte a SSL](../../connect/jdbc/understanding-ssl-support.md). |
| NOMEDAINSTÂNCIA<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | O nome da instância do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] à qual se conectar. Quando ela não for especificada, uma conexão será estabelecida com a instância padrão. Para o caso em que instanceName e a porta forem especificadas, veja as observações para a porta.<br/><br/> Se você especificar um nome de rede virtual na propriedade de conexão **Server**, não poderá usar a propriedade de conexão **instanceName**. Ver [suporte do Driver JDBC para alta disponibilidade, recuperação de desastres](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) para obter mais informações. |
| integratedSecurity<br/><br/>booleano<br/>["true"&#124;"false"]<br/><br/>false | Defina como "true" para indicar que as credenciais do Windows são usadas pelos [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] em sistemas de operacionais do Windows. Se "true", o driver JDBC procurará no cache da credencial do computador local as credenciais que já foram fornecidas no computador ou no logon da rede.<br/><br/> Definido como "true" (com **authenticationscheme = JavaKerberos**), para indicar que as credenciais do Kerberos são usadas pelos [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Para obter mais informações sobre a autenticação do Kerberos, confira [Como usar a autenticação integrada do Kerberos para se conectar ao SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). <br/><br/> Se "false", o nome de usuário e a senha deverão ser fornecidos. |
| jaasConfigurationName<br/><br/>Cadeia de caracteres<br/><br/>SQLJDBCDriver | Começando com o Microsoft JDBC Driver 6.2 para SQL Server, cada conexão com o SQL Server pode ter seu próprio arquivo de configuração de logon JAAS para estabelecer a conexão de Kerberos. Nome do arquivo de configuração de logon pode ser passado através desta propriedade. <br/> Por padrão, driver define a propriedade `useDefaultCcache = true` para IBM JVMs, e `useTicketCache = true` para outros JVMs. |
| keyStoreAuthentication<br/><br/>Cadeia de caracteres<br/><br/>nulo | Começando com o Microsoft JDBC Driver 6.0 para SQL Server, essa propriedade identifica qual repositório de chaves definidos diretamente para a conexão com o Always Encrypted e determina um mecanismo de autenticação usado para autenticar para o repositório de chaves. Microsoft JDBC Driver 6.0 para SQL Server dá suporte a configuração até de Store de chave de Java diretamente usando essa propriedade para o qual você precisa definir "**keyStoreAuthentication = JavaKeyStorePassword**". Observe que para usar essa propriedade, você também precisa definir a **keyStoreLocation** e **keyStoreSecret** propriedades para a Store de chave Java. <br/><br/>Para obter mais informações, visite [Como usar Always Encrypted com o driver JDBC](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| keyStoreLocation<br/><br/>Cadeia de caracteres<br/><br/>nulo | Quando **keyStoreAuthentication = JavaKeyStorePassword**, o **keyStoreLocation** propriedade identifica o caminho para o arquivo de repositório de chaves Java que armazena a chave mestra de coluna a ser usado com o Always Encrypted dados. Observe que o caminho deve incluir o nome do arquivo de repositório de chaves.<br/><br/>Para obter mais informações, visite [Como usar Always Encrypted com o driver JDBC](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| keyStoreSecret<br/><br/>Cadeia de caracteres<br/><br/>nulo | Quando **keyStoreAuthentication = JavaKeyStorePassword**, o **keyStoreSecret** propriedade identifica a senha a ser usado para o repositório de chaves, bem como para a chave. Observe que, para usar a chave de Java Store o repositório de chaves e a senha da chave deve ser o mesmo.<br/><br/>Para obter mais informações, visite [Como usar Always Encrypted com o driver JDBC](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| lastUpdateCount<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | Um valor "true" só retorna a contagem de atualização mais recente de uma instrução SQL passada para o servidor, podendo ser usado em instruções SELECT, INSERT ou DELETE para ignorar contagens de atualização adicionais causadas por gatilhos de servidor. A definição dessa propriedade como "false" faz com que todas as contagens de atualização sejam retornadas, inclusive as retornadas por gatilhos de servidor.<br/><br/> **Observação:** essa propriedade só se aplica quando usada com os métodos [executeUpdate](../../connect/jdbc/reference/executeupdate-method-sqlserverstatement.md). Todos os outros métodos execute retornam todos os resultados e as contagens de atualização. Essa propriedade só afeta contagens de atualização retornadas por gatilhos de servidor. Ela não afeta conjuntos de resultados ou erros resultantes de parte da execução do gatilho. |
| lockTimeout<br/><br/>INT<br/><br/>-1 | O número de milissegundos para aguardar antes do banco de dados informar um tempo limite de bloqueio. O comportamento padrão é aguardar indefinidamente. Se for especificado, esse valor será o padrão para todas as instruções na conexão. Observe que **Statement.setQueryTimeout()** pode ser usado para definir o tempo limite de instruções específicas. O valor pode ser 0, que especifica a ausência de espera. |
| loginTimeout<br/><br/>INT<br/>[0..65535]<br/><br/>15 | O número de segundos que o driver deve aguardar antes que o tempo limite de uma conexão com falha seja alcançado. Um valor igual a zero indica que o tempo limite é o padrão do sistema, especificado como 15 segundos por padrão. Um valor diferente de zero é o número de segundos que o driver deve aguardar antes do tempo limite de uma conexão com falha.<br/><br/> Se você especificar um nome de rede virtual na propriedade de conexão **Server**, especifique um valor de tempo limite de três minutos ou mais para dar tempo suficiente para a conexão de failover ter êxito. Ver [suporte do Driver JDBC para alta disponibilidade, recuperação de desastres](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) para obter mais informações. |
| msiClientId<br/><br/>Cadeia de caracteres<br/><br/>nulo | A ID do cliente do MSI Managed Service Identity () a ser usado para adquirir **accessToken** ao estabelecer uma conexão com o **ActiveDirectoryMSI** modo de autenticação.|
| multiSubnetFailover<br/><br/>Booliano<br/><br/>false | Sempre especifique **multiSubnetFailover=True** ao se conectar ao ouvinte de um grupo de disponibilidade do [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] ou a uma instância de cluster de failover do [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]. **multiSubnetFailover=true** configura o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] para fornecer mais rapidez na detecção do servidor ativo (atualmente) e na conexão a ele. Os valores possíveis são true e false. Ver [suporte do Driver JDBC para alta disponibilidade, recuperação de desastres](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) para obter mais informações.<br/><br/> Você pode acessar de forma programática a propriedade de conexão **multiSubnetFailover** com [getPropertyInfo](../../connect/jdbc/reference/getpropertyinfo-method-sqlserverdriver.md), [getMultiSubnetFailover](../../connect/jdbc/reference/getmultisubnetfailover-method-sqlserverdatasource.md) e [setMultiSubnetFailover](../../connect/jdbc/reference/setmultisubnetfailover-method-sqlserverdatasource.md).<br/><br/> **Observação:** começando com o Microsoft JDBC Driver 6.0 para SQL Server, ele não é mais necessário definir **multiSubnetFailover** como "true" ao se conectar a um ouvinte de grupo de disponibilidade. Uma nova propriedade, **transparentNetworkIPResolution**, que é habilitado por padrão, fornece a detecção e a conexão com o servidor ativo (atualmente). |
| packetSize<br/><br/>INT<br/>[-1 &#124; 0 &#124; 512..32767]<br/><br/>8000 | O tamanho do pacote de rede usado para se comunicar com o SQL Server, especificado em bytes. Um valor igual a -1 indica o uso do tamanho de pacote padrão do servidor. Um valor igual a 0 indica o uso do valor máximo, 32767. Se essa propriedade for definida como um valor fora do intervalo aceitável, ocorrerá uma exceção.<br/><br/> **Importante:** não recomendamos o uso da propriedade packetSize quando a criptografia estiver habilitada (encrypt=true). Do contrário, o driver pode acionar um erro na conexão. Para obter mais informações, veja o método [setPacketSize](../../connect/jdbc/reference/setpacketsize-method-sqlserverdatasource.md) da classe [SQLServerDataSource](../../connect/jdbc/reference/sqlserverdatasource-class.md). |
| password<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | A senha do banco de dados, no caso de conexão com o usuário do SQL e a senha.<br/>Para a conexão de Kerberos com o nome da entidade e senha, essa propriedade é definida como senha da entidade de segurança Kerberos. |
| portNumber,<br/>port<br/><br/>INT<br/>[0..65535]<br/><br/>1433 | A porta em que [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] está escutando. Se o número da porta for especificado na cadeia de conexão, nenhuma solicitação para SQLbrowser será feita. Quando a porta e instanceName forem especificadas, a conexão será estabelecida com a porta especificada. No entanto, **instanceName** será validado e um erro será lançado se não corresponder à porta.<br/><br/> **Importante:** recomendamos que o número da porta seja especificado sempre, porque isso é mais seguro do que o uso de SQLbrowser. |
| queryTimeout<br/><br/>INT<br/><br/>-1 | O número de segundos a aguardar antes de um tempo limite ocorreu em uma consulta. O valor padrão é -1, o que significa que o tempo limite infinito. Configuração como 0 também implica para aguardar indefinidamente. |
| responseBuffering<br/><br/>Cadeia de caracteres<br/>["full" &#124; "adaptive"]<br/><br/>adaptive | Se essa propriedade for definida como "adaptive", o mínimo de dados possíveis será armazenado em buffer quando necessário. O modo padrão é "adaptável".<br/><br/> Quando essa propriedade for definida como "full", todo o conjunto de resultados será lido no servidor quando uma instrução for executada.<br/><br/> **Observação:** depois de atualizar o JDBC Driver da versão 1.2, o comportamento de armazenamento em buffer padrão será "adaptável". Se o aplicativo nunca tiver definido a propriedade "responseBuffering" e você quiser manter o comportamento padrão da versão 1.2 no aplicativo, será preciso definir a propriedade responseBufferring como "full" nas propriedades da conexão ou usando o método [setResponseBuffering](../../connect/jdbc/reference/setresponsebuffering-method-sqlserverstatement.md) do objeto [SQLServerStatement](../../connect/jdbc/reference/sqlserverstatement-class.md). |
| selectMethod<br/><br/>Cadeia de caracteres<br/>["direct" &#124; "cursor"]<br/><br/>direct | Se essa propriedade for definida como "cursor", um banco de dados será criado para cada consulta criada na conexão dos cursores **TYPE_FORWARD_ONLY** e **CONCUR_READ_ONLY**. Essa propriedade só costuma ser obrigatória caso o aplicativo gere conjuntos de resultados grandes que não possam estar inteiramente contidos na memória do cliente. Quando essa propriedade estiver definida como "cursor", apenas um número limitado de linhas do conjunto de resultados será mantido na memória do cliente. <br/><br/>O comportamento padrão é que todas as linhas do conjunto de resultados sejam mantidas na memória do cliente. Esse comportamento fornece o melhor desempenho quando o aplicativo processa todas as linhas. |
| sendStringParameters...<br/>AsUnicode<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | *sendStringParametersAsUnicode*<br/><br/>Se a propriedade **sendStringParametersAsUnicode** for definida como "true", os parâmetros String serão enviados para o servidor no formato Unicode.<br/><br/> Se a propriedade **sendStringParametersAsUnicode** for definida como "false", os parâmetros da cadeia de caracteres serão enviados para o servidor no formato não Unicode, como ASCII/MBCS, em vez de Unicode.<br/><br/> O valor padrão da propriedade **sendStringParametersAsUnicode** é "true".<br/><br/> **Observação:** a propriedade **sendStringParametersAsUnicode** é verificada apenas durante o envio de um valor de parâmetro com os tipos JDBC **CHAR**, **VARCHAR** ou **LONGVARCHAR**. Os novos métodos de caractere nacional JDBC 4.0, como os métodos setNString, setNCharacterStream e setNClob das classes [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) e [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) sempre enviam os valores de parâmetro para o servidor em Unicode, independentemente da configuração dessa propriedade.<br/><br/> Para obter o desempenho ideal com os tipos de dados **CHAR**, **VARCHAR** e **LONGVARCHAR**, um aplicativo deve definir a propriedade **sendStringParametersAsUnicode** como "false" e usar os métodos de caractere não nacional setString, setCharacterStream e setClob das classes [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) e [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md).<br/><br/> Quando o aplicativo define a propriedade **sendStringParametersAsUnicode** como "false" e usa um método de caractere não nacional para acessar tipos de dados Unicode no lado do servidor (como **nchar**, **nvarchar** e **ntext**), alguns dados podem ser perdidos caso a ordenação do banco de dados não dê suporte aos caracteres nos parâmetros da cadeia de caracteres passados pelo método de caractere não nacional.<br/><br/> Observe que um aplicativo deve usar os métodos de caractere nacional setNString, setNCharacterStream e setNClob do [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) e [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) classes para o **NCHAR**, **NVARCHAR**, e **LONGNVARCHAR** tipos de dados JDBC. |
| sendTimeAsDatetime<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | Essa propriedade foi adicionada ao [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] JDBC Driver 3.0.<br/><br/> Defina como "true" para enviar valores de time para o servidor como [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **datetime** valores. <br/>Definido como "false" para enviar os valores time ao servidor como [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **tempo** valores.<br/><br/> O valor padrão para essa propriedade é "true" no momento e pode mudar em uma versão futura.<br/><br/> Para obter mais informações sobre como o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] configura os valores time antes de enviá-los para o servidor, consulte [configurando como os valores time são enviados ao servidor](../../connect/jdbc/configuring-how-java-sql-time-values-are-sent-to-the-server.md). |
| serverName,<br/>servidor<br/><br/>Cadeia de caracteres<br/><br/>nulo | O computador no qual o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] está em execução.<br/><br/> Você também pode especificar o Nome de Rede Virtual de um grupo de disponibilidade [!INCLUDE[ssHADR](../../includes/sshadr_md.md)]. Ver [suporte do Driver JDBC para alta disponibilidade, recuperação de desastres](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) para obter mais informações. |
| serverNameAsACE<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | Começando com o Microsoft JDBC Driver 6.0 for SQL Server, definido como “true” para indicar que o driver deve traduzir o nome do servidor Unicode para a codificação compatível ASCII (Punycode) para a conexão. Se essa configuração for “false”, o driver se conecta usando o nome do servidor, conforme fornecido pelo usuário.<br/><br/> Ver [recursos internacionais do JDBC Driver](../../connect/jdbc/international-features-of-the-jdbc-driver.md) para obter mais detalhes. |
| serverPreparedStatement...<br/>DiscardThreshold<br/><br/>Integer<br/><br/>10 | *serverPreparedStatementDiscardThreshold*<br/><br/>Começando com o JDBC Driver 6.2 para SQL Server, essa propriedade pode ser usada para controlar quantos pendentes instrução preparada ações de descarte (<code>sp_unprepare</code>) pode estar pendente por conexão antes de uma chamada para limpar os identificadores pendentes no servidor é executada . <br/><br/> Se essa propriedade é definida como &lt;= 1, unprepare ações são executadas imediatamente na instrução preparada fechar. Se ele for definido como &gt;1 essas chamadas são agrupados em lotes, para evitar a sobrecarga da chamada sp_unprepare com muita frequência. |
| serverSpn<br/><br/>Cadeia de caracteres<br/><br/>nulo | A partir do Microsoft JDBC Driver 4.2 para SQL Server, essa propriedade opcional pode ser usada para especificar o Nome da Entidade de Serviço (SPN) para uma conexão Kerberos Java.  Ele é usado em conjunto com **authenticationScheme**.<br/><br/> Para especificar a SPN, ela pode estar na forma de: "MSSQLSvc/fqdn:port@REALM" – em que fqdn é o nome de domínio totalmente qualificado, porta é o número da porta e REALM é o realm de Kerberos do SQL Server em letras maiúsculas.<br/><br/> Observação: o @REALM será opcional se o realm padrão do cliente (conforme especificado na configuração do Kerberos) for o mesmo que o realm do Kerberos para o SQL Server.<br/><br/> Para obter mais informações sobre o uso do **serverSpn** com o Java Kerberos, confira [Usando a autenticação integrada Kerberos para conectar-se ao SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). |
| statementPooling...<br/>CacheSize<br/><br/>INT<br/><br/>0 | *statementPoolingCacheSize*<br/><br/>Começando com o JDBC Driver 6.4 para SQL Server, essa propriedade pode ser usada para habilitar a instrução preparada lidar com cache no driver. <br/><br/>Esta propriedade define o tamanho do cache para o pooling de instrução. <br/><br/>Essa propriedade só pode ser usada em conjunto com **disableStatementPooling** propriedade de conexão que deve ser definida como "false". Definindo **disableStatementPooling** como "true" ou **statementPoolingCacheSize** para 0 desabilita instrução preparada manipular o cache.|
| socketTimeout<br/><br/>INT<br/><br/>0 | O número de milissegundos de espera antes da ocorrência de um tempo limite em um soquete de leitura ou aceita. O valor padrão é 0, o que significa que o tempo limite infinito. |
| sslProtocol<br/><br/>Cadeia de caracteres<br/><br/>TLS | Começando com o JDBC Driver 6.4 para SQL Server, essa propriedade pode ser usada para especificar o protocolo TLS a serem considerados durante a conexão segura. <br/>Os valores possíveis são: **TLS**, **TLSv1**, **TLSv1.1** e **TLSv1.2**. <br/><br/>Para obter mais informações, consulte [SSLProtocol](https://github.com/Microsoft/mssql-jdbc/wiki/SSLProtocol). |
| transparentNetwork...<br/>IPResolution<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | *transparentNetworkIPResolution*<br/><br/>Começando com o Microsoft JDBC Driver 6.0 para SQL Server, esta propriedade fornece detecção mais rápida e conexão para o servidor ativo (atualmente). Os valores possíveis são "true" e "false" onde "true" é o valor padrão.<br/><br/> Antes do Microsoft JDBC Driver 6.0 para SQL Server, um aplicativo tinha que definir a cadeia de conexão para incluir "multiSubnetFailover = true" para indicar que ele estava se conectando a um grupo de disponibilidade do AlwaysOn. Sem definir a palavra-chave de conexão **multiSubnetFailover** como "true", um aplicativo pode enfrentar um tempo limite ao se conectar a um Grupo de disponibilidade AlwaysOn. Começando com o Microsoft JDBC Driver 6.0 para SQL Server, um aplicativo não precisa definir multiSubnetFailover como true mais. <br/><br/>**Observação:** quando transparentNetworkIPResolution = true, o primeiro usa de tentativa de conexão 500 ms, como o tempo limite. Quaisquer tentativas subsequentes de usam a mesma lógica de tempo limite usado pela propriedade multiSubnetFailover. |
| trustManagerClass<br/><br/>Cadeia de caracteres<br/><br/>nulo | O nome de classe totalmente qualificado de um personalizado <code>javax.net.ssl.TrustManager</code> implementação. |
| trustManager...<br/>ConstructorArg<br/><br/>Cadeia de caracteres<br/><br/>nulo | *trustManagerConstructorArg*<br/><br/>Um argumento opcional para passar para o construtor da TrustManager. Se trustManagerClass for especificado e uma conexão criptografada é solicitada, o TrustManager personalizado é usado em vez de sistema padrão da JVM com base no repositório de chaves TrustManager. |
| trustServerCertificate<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | Defina como "true" para especificar que o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] não valida o certificado SSL do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].<br/><br/> Se "true", o certificado SSL do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] será considerado confiável automaticamente quando a camada de comunicação for criptografada com SSL.<br/><br/> Se "false", o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] valida o certificado SSL do servidor. Se houver falha na validação do certificado do servidor, o driver lançará um erro e encerrará a conexão. O valor padrão é "falso". Verifique se o valor passado para **serverName** corresponde exatamente ao CN (Nome Comum) ou ao nome DNS no Nome Alternativo da Entidade no certificado do servidor para que uma conexão SSL tenha êxito. Para obter mais informações, consulte [Noções básicas sobre suporte a SSL](../../connect/jdbc/understanding-ssl-support.md).<br/><br/> **Observação:** essa propriedade é usada em combinação com o **criptografar**/**autenticação** propriedades. Essa propriedade só afetará a validação do certificado SSL do servidor se e somente se a conexão usa criptografia SSL. |
| trustStore<br/><br/>Cadeia de caracteres<br/><br/>nulo | O caminho (inclusive o nome de arquivo) para o arquivo trustStore do certificado. O arquivo trustStore contém a lista de certificados nos quais o cliente confia.<br/><br/> Quando essa propriedade não for especificada ou for definida como nula, o driver contará com as regras de pesquisa de fábrica do gerenciador de confiança para determinar que repositório de certificados usar.<br/><br/> **O padrão SunX509 TrustManagerFactory tenta localizar o material confiável na seguinte ordem de pesquisa:**<br/><br/> Um arquivo especificado pela propriedade do sistema JVM (Máquina Virtual Java) "javax.net.ssl.trustStore".<br/><br/> Arquivo "&lt;java-home&gt;/lib/security/jssecacerts".<br/><br/> Arquivo "&lt;java-home&gt;/lib/security/cacerts".<br/><br/> <br/><br/> Para obter mais informações, consulte a documentação do SUNX509 TrustManager Interface no site da Sun Microsystems.<br/><br/> **Observação:** essa propriedade afeta apenas a pesquisa trustStore do certificado se e somente se a conexão usa criptografia SSL e o **trustServerCertificate** propriedade é definida como "false". |
| trustStorePassword<br/><br/>Cadeia de caracteres<br/><br/>nulo | A senha usada para verificar a integridade dos dados de trustStore.<br/><br/> Se a propriedade trustStore for definida, mas a propriedade trustStorePassword não for definida, a integridade de trustStore não será verificada.<br/><br/> Quando as propriedades trustStore e trustStorePassword não forem especificadas, o driver usará as propriedades do sistema JVM, "javax.net.ssl.trustStore" e "javax.net.ssl.trustStorePassword". Se a propriedade do sistema "javax.net.ssl.trustStorePassword" não for especificada, a integridade de trustStore não será verificada.<br/><br/> Se a propriedade trustStore não estiver definida, mas a propriedade trustStorePassword estiver, o driver JDBC usará o arquivo especificado por "javax.net.ssl.trustStore" como um repositório confiável e a integridade dele será verificada com trustStorePassword. Isso pode ser necessário quando o aplicativo cliente não quiser armazenar a senha na propriedade do sistema JVM.<br/><br/> **Observação:** a propriedade trustStorePassword só afeta a pesquisa trustStore do certificado se e somente se a conexão usa a conexão SSL e o **trustServerCertificate** propriedade é definida como "false". |
| trustStoreType<br/><br/>Cadeia de caracteres<br/><br/>JKS | Defina essa propriedade para especificar o tipo de repositório de confiança a ser usado para o modo FIPS. <br/><br/>Os valores possíveis são **PKCS12** ou tipo definido pelo provedor FIPS. |
| useBulkCopyFor...<br/>BatchInsert<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | _useBulkCopyForBatchInsert_<br/><br/> Começando com o Microsoft JDBC Driver 7.0 para SQL Server, essa propriedade de conexão pode ser habilitada para fazer uso da API de cópia em massa ao executar operações de inserção em lotes usando <code>java.sql.PreparedStatement</code> para melhorar o desempenho. <br/><br/>Esse recurso está funcionando apenas quando o servidor de destino é do tipo **Data Warehouse do Azure**. Ela é desabilitada por padrão, defina essa propriedade como "true" para habilitar esse recurso. <br/></br> **Observação importante:** esse recurso só dá suporte a consultas parametrizadas totalmente de inserir. Se as consultas INSERT são combinadas por outras consultas SQL ou contêm dados em valores, execução fará o fallback para a operação de inserção em lotes básica. <br/><br/> Para obter mais informações sobre como usar essa propriedade, consulte [usando o API de cópia em massa para a operação de inserção de lote](use-bulk-copy-api-batch-insert-operation.md)|
| userName,<br/>usuário<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | O usuário de banco de dados, no caso de conexão com o usuário do SQL e a senha.<br/><br/>Conexão de Kerberos com o nome da entidade e senha, essa propriedade é definida com o nome de entidade de segurança Kerberos. |
| workstationID<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>&lt;cadeia de caracteres vazia&gt; | A ID da estação de trabalho. Usado para identificar a estação de trabalho específica em várias ferramentas de criação de perfil e de registro em log do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. <br/><br/>Se nenhum for especificado, a &lt;cadeia de caracteres vazia&gt; será usada. |
| xopenStates<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | Defina como "true" para especificar que o driver retorna códigos de estado compatíveis com XOPEN em exceções. <br/><br/>O padrão é retornar códigos de estado SQL 99. |
| &nbsp; | &nbsp; |

> [!NOTE]  
> O [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] recebe os valores padrão do servidor para propriedades de conexão, exceto para ANSI_DEFAULTS e IMPLICIT_TRANSACTIONS. O [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] define automaticamente ANSI_DEFAULTS como ON e IMPLICIT_TRANSACTIONS como OFF.

> [!Important]
> Se a autenticação está definida como ActiveDirectoryPassword, a seguinte biblioteca deve ser incluído no classpath: [azure-activedirectory-library-for-java](https://github.com/AzureAD/azure-activedirectory-library-for-java). Ele pode ser encontrado no [Repositório Maven](https://mvnrepository.com/artifact/com.microsoft.azure/adal4j). A maneira mais simples para baixar a biblioteca e suas dependências usando o Maven: 
> 1. Primeiro, instale o Maven em seu sistema 
> 2. Vá para o [página do GitHub](https://github.com/Microsoft/mssql-jdbc) do driver
> 3. Baixe o arquivo POM. XML
> 4. Execute o seguinte comando do Maven para baixar a biblioteca e suas dependências: `mvn dependency:copy-dependencies`

## <a name="see-also"></a>Consulte Também

[Conectando ao SQL Server com o JDBC Driver](../../connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver.md)  
[Modo FIPS](../../connect/jdbc/fips-mode.md)
